# bufLab实验报告
软件52班 张迁瑞 2015013226
## 实验环境
实验使用操作系统为腾讯云服务器，操作系统为 Ubuntu 14.04。

所用Cookie: 0x1fb3d168。
## 解题过程
### Level 0:Candle（烛)
本关要求通过缓冲区溢出，使函数**getbuf()**执行后直接执行smoke()函数，而不执行后面的代码。

首先我进行了一些准备工作，比如写个脚本方便本地测试：

	bufLab/answer1.sh
	#bin/bash
	./hex2raw < answer1.txt > answer1-raw.txt
	./bufbomb -u 2015013226 < answer1-raw.txt

把bufbomb反汇编：

	objdump -d bufbomb > bufbomb.s

为了研究**getbuf()**的行为,我首先查看了它的汇编代码

	8049284:	55                   	push   %ebp
 	8049285:	89 e5                	mov    %esp,%ebp
 	8049287:	83 ec 38             	sub    $0x38,%esp
 	804928a:	8d 45 d8             	lea    -0x28(%ebp),%eax
 	804928d:	89 04 24             	mov    %eax,(%esp)
	8049290:	e8 d1 fa ff ff       	call   8048d66 <Gets>
 	8049295:	b8 01 00 00 00       	mov    $0x1,%eax
 	804929a:	c9                   	leave  
 	804929b:	c3                   	ret

重点是4，5行，尽管先前为栈提供了0x38个字节的空间，但执行过这两行的指令之后，栈上的空间只剩下了0x28(我不会说开始我把这个当成了28/4 = 7个字节)的空间，也就是40个字节。所以，只要输入超过40个字节，正常的栈结构就会被破坏。

注：我尚未理解为什么这里不直接分配0x28,而是要用这种麻烦的方法。

被破坏掉的地方，开始是保存的ebp的值(4个字节)，之后就是返回地址。也就是说，只要随便输入44个字节，最后四个字节再改成smoke()的地址，这一关就可以成功了。

于是，再去找到smoke()的地址

	08048b04   <smoke>：

将08048b04按照小端模式"04 8b 04 08"放在最后四个字节，实验顺利完成！Smoke()!

值得一提的是，尽管test中有用来保护栈的canary，但因为出事的是getbuf,它连刷存在感的机会都没有。

### Level 1: Sparkler(闪烁)
和上一关类似，同样是要返回一个函数fizz(int val)，唯一不同的是这个函数是带参数的。

同样先找到fizz的位置

	08048b2e <fizz>:

用这个地址替换掉上一关中smoke的地址。

### Level 2: Firecracker(花火)

### Level 3: Dynamite(炸药)

### Level 4: Nitroglycerin(硝化甘油)

## 感想
不得不说，这个实验太棒了。实验的英文文档很精彩，几个任务的名称Candle,Sparkler...和"bomb"紧密相关，成功和失败的函数提示也很好玩，像什么smoke(),fizz(嘶嘶声), dub(哑弹)...，让人在写作业的时候感觉就像在玩一个游戏，没有觉得烦，不知不觉就完成了实验，甚至还有些意犹未尽。 更重要的是，这个实验的负担还不大，也没有让人绞尽脑汁的“自由发挥”内容。如果所有的大作业都像这样多好，杨老师和这门课的助教真是太厉害了！清华大学的计算机学科不愧是世界第一！

当然，后来我还是知道了buflab的出处。