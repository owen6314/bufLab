# bufLab实验报告
软件52班 张迁瑞 2015013226
## 实验环境
实验使用操作系统为腾讯云服务器，操作系统为 Ubuntu 14.04。

所用Cookie: 0x1fb3d168。
## 解题过程
### Level 0:Candle（烛)
本关要求通过缓冲区溢出，使函数**getbuf()**执行后直接执行smoke()函数，而不执行后面的代码。

首先我进行了一些准备工作，比如写个脚本方便本地测试：

	bufLab/answer1.sh
	#bin/bash
	./hex2raw < answer1.txt > answer1-raw.txt
	./bufbomb -u 2015013226 < answer1-raw.txt

把bufbomb反汇编：

	objdump -d bufbomb > bufbomb.s

为了研究**getbuf()**的行为,我首先查看了它的汇编代码

	8049284:	55                   	push   %ebp
 	8049285:	89 e5                	mov    %esp,%ebp
 	8049287:	83 ec 38             	sub    $0x38,%esp
 	804928a:	8d 45 d8             	lea    -0x28(%ebp),%eax
 	804928d:	89 04 24             	mov    %eax,(%esp)
	8049290:	e8 d1 fa ff ff       	call   8048d66 <Gets>
 	8049295:	b8 01 00 00 00       	mov    $0x1,%eax
 	804929a:	c9                   	leave  
 	804929b:	c3                   	ret

重点是4，5行，尽管先前为栈提供了0x38个字节的空间，但执行过这两行的指令之后，栈上的空间只剩下了0x28(我不会说开始我把这个当成了28/4 = 7个字节)的空间，也就是40个字节。所以，只要输入超过40个字节，正常的栈结构就会被破坏。

注：我尚未理解为什么这里不直接分配0x28,而是要用这种麻烦的方法。

被破坏掉的地方，开始是保存的ebp的值(4个字节)，之后就是返回地址。也就是说，只要随便输入44个字节，最后四个字节再改成smoke()的地址，这一关就可以成功了。

于是，再去找到smoke()的地址

	08048b04   <smoke>：

将08048b04按照小端模式"04 8b 04 08"放在最后四个字节，实验顺利完成！Smoke()!

值得一提的是，尽管test中有用来保护栈的canary，但因为出事的是getbuf,它连刷存在感的机会都没有。

### Level 1: Sparkler(闪烁)
和上一关类似，同样是要返回一个函数fizz(int val)，唯一不同的是这个函数是带参数的，需要在覆盖的时候把参数也放进去。

同样先找到fizz的位置

	08048b2e   <fizz>:

用这个地址替换掉上一关中smoke的地址。

接下来再通过汇编代码确定参数的位置（也可以通过课上讲的知识确定），这里的参数为

	 8048b34:	8b 55 08             	mov    0x8(%ebp),%edx

也就是在ebp + 8的位置，因此，我们需要先放四个字节的任意数据，再把自己的userid放上去。

如此一试，果然成功！

### Level 2: Firecracker(花火)
本关的要求是，通过输入的字符串，使得程序getbuf后不返回test，而是执行bang中的代码，同时还要修改global_value的值为自己的cookie值。

与前两关相比，这一关的操作bang了许多，因为我们不仅改变了函数的返回地址，还改变了程序中的全局变量，开始有点黑客的味道了！

这一关的总体实现思路是这样的：首先，我们通过栈溢出，覆盖掉getbuf原来的返回值，并把它改成我们想要插入的代码的地址，这样，getbuf就会在我们想让其返回的地方返回，并会执行预先设置在那里的代码（即改变global_value)。在执行完这段代码之后，再通过设置让程序返回bang函数。为了方便寻址，我把插入代码的位置设置为buf的首地址。

为了达到前述要求，显然需要得到global_value的地址。这里，我第一次使用gdb（前两关都是通过反汇编找的地址）进行调试。开始以为没有图形界面的调试很难受，但用起来之后却觉得还好，至少命令很直观。

	p &global_value
	$2 = (<data variable, no debug info> *) 0x804e10c <global_value>

然后，按照书上的提示，我开始用汇编写改变这个全局变量的代码(3.S):

	movl $0x1fb3d168, %eax  ;前者是我的id
	movl %eax, 0x804e10c	;改global_value的值

该怎么让这些代码执行完之后返回bang呢？直接ret显然是不行的，因为我们的代码不是走正常渠道来的，显然不能用正常的方法返回。但是考虑到ret的实质是popl %eip,而%eip里面是下一条执行指令的位置，我们可以先把我们希望它回到的地址压栈，这样ret之后自然就到那里了。

于是，找到我们想让函数返回的位置，并将其压栈后返回。

	pushl $0x08048b82
	ret

再把这四条语句转为指令形式:

	gcc -m32 -c 3.S
	objdump -d 3.o > 3.d

查看3.d，将生成的文本作为这次答案的前半段。

最后，就要找buf的地址了。这个找到的地址将被放在攻击字符串的最后，以使得getbuf之后直接跳转到这个地址。

找buf的地址颇费了一番周折，本想直接`p &buf`拿到地址，然而并没有找到。查找资料发现，应该是局部变量被编译器用寄存器优化掉了。看来，只能用寄存器中的值推buf了。在文档的前面，我们曾提到过，buf的地址在%ebp中的值的上面0x28处，故

	p ($ebp - 0x28) ;越往上值越小

得到buf地址，放在字符串的最后，成功破关。


### Level 3: Dynamite(炸药)
这一关的要求是在修改global_value的基础上，不改变原来的栈结构，仍然让其返回test,这样，程序会以为一切正常，照常执行test中在getbuf之后的代码。然而，炸弹已经悄悄被注入到了程序之中。

实验的思路和上一关很相似，不同的是，我们要返回test在执行getbuff后下面一条语句的位置，还要恢复被破坏掉的栈状态。前者很容易，在bufbomb.s中找一下地址就可以，但是我们应该如何恢复栈的状态呢？


### Level 4: Nitroglycerin(硝化甘油)

## 感想
不得不说，这个实验太棒了。实验的英文文档很精彩，几个任务的名称Candle,Sparkler...和"bomb"紧密相关，成功和失败的函数提示也很好玩，像什么smoke(),fizz(嘶嘶声), dub(哑弹)...，让人在写作业的时候感觉就像在玩一个游戏，没有觉得烦，不知不觉就完成了实验，甚至还有些意犹未尽。 更重要的是，这个实验的负担还不大，也没有让人绞尽脑汁的“自由发挥”内容。如果所有的大作业都像这样多好，杨老师和这门课的助教真是太厉害了！清华大学的计算机学科不愧是世界第一！

当然，后来我还是知道了buflab的出处。